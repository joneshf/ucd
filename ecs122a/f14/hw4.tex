\documentclass[12pt,letterpaper]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{cancel}
\usepackage[margin=1in]{geometry}
\usepackage{titling}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{wasysym}
\usepackage{qtree}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\lb}[0]{\text{lg}}

\setlength{\droptitle}{-10ex}

\preauthor{\begin{flushright}\large \lineskip 0.5em}
\postauthor{\par\end{flushright}}
\predate{\begin{flushright}\large}
\postdate{\par\end{flushright}}

\title{ECS 122A Homework 4\vspace{-2ex}}
\author{Hardy Jones\\
        999397426\\
        Professor Gysel\vspace{-2ex}}
\date{Fall 2014}

\begin{document}
  \maketitle

  \begin{enumerate}
    \item

      We can find a possible augmenting path if we modify both of the given algorithms.

      For DFS, we do not need to look at each vertex when starting the algorithm.
      We already know we want to find a path from $s$ to $t$, so we just need to check for paths from $s$.

      For DFS-VISIT, we should check if the current vertex is $t$.
      If it is, then we've constructed an $st$-path, and we can just return it.
      Otherwise, we continue as in the original algorithm.
      Each time we visit a new vertex, we add it to the end of the current path.
      If what was returned from our visitation is not an empty list,
      then we have an $st$-path, so we can return it.
      Otherwise, we continue searching for paths.
      If at the end of the search, we didn't find $t$, we return the empty list.

      \begin{algorithm}
        \begin{algorithmic}
          \Function{AUGMENTING-PATH}{$G_f$}
            \For{each $v \in G_f$}
              \State $v$.visited $\gets$ \textsc{False}
            \EndFor
            \State \Return ST-PATH($G_f$, $G_f.s$, APPEND(\textsc{Nil}, $G_f.s$))
          \EndFunction
        \end{algorithmic}
      \end{algorithm}

      \begin{algorithm}
        \begin{algorithmic}
          \Function{ST-PATH}{$G$, $v$, $l$}
            \State $v$.visited $\gets$ \textsc{True}
            \If{$v == G.t$}
              \State \Return $l$
            \EndIf
            \For{each $u \in G.$Adj($v$)}
              \If{$u$.visited $==$ \textsc{False}}
                \State $path? \gets$ ST-PATH($G$, $u$, APPEND($l$, $u$))
                \If{$path? \ne $ \textsc{Nil}}
                  \State \Return $path?$
                \EndIf
              \EndIf
            \EndFor
            \State \Return \textsc{Nil}
          \EndFunction
        \end{algorithmic}
      \end{algorithm}

    \item
    \item
      \begin{enumerate}
        \item True
          \[
            v(f) = f_{OUT}(s) - f_{IN}(s) = f_{OUT}(s) = f_{IN}(u_1) = f_{OUT}(u_1) = f_{IN}(u_2) = \dots = f_{IN}(t)
          \]
        \item False
          Minimum cuts are equivalent to maximum flow
          by the Max-flow min-cut theorem.
        \item False
          The while loop in FORD-FULKERSON has complexity $O(|E|)$ since the path can be found with either BFS or DFS, both of which have complexity $O(|E|)$.
        \item True
          This satisfies both the capacity and the conservation constraints.
      \end{enumerate}
  \end{enumerate}
\end{document}
