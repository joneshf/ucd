\documentclass[12pt,letterpaper]{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{cancel}
\usepackage[margin=1in]{geometry}
\usepackage{titling}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}

\newcommand{\Mod}[1]{\ (\text{mod}\ #1)}

\setlength{\droptitle}{-10ex}

\preauthor{\begin{flushright}\large \lineskip 0.5em}
\postauthor{\par\end{flushright}}
\predate{\begin{flushright}\large}
\postdate{\par\end{flushright}}

\title{ECS 120 Problem Set 2\vspace{-2ex}}
\author{Hardy Jones\\
        999397426\\
        Professor Rogaway\vspace{-2ex}}
\date{Spring 2014}

\begin{document}
  \maketitle

  \begin{enumerate}
    \item[Problem 1]
      \begin{enumerate}
        \item
          \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
             \node[state,initial] (q_0)   {$q_0$};
             \node[state] (q_1) [right=of q_0] {$q_1$};
             \node[state] (q_2) [right=of q_1] {$q_2$};
             \node[state,accepting](q_3) [right=of q_2] {$q_3$};
              \path[->]
              (q_0) edge  node {a,b} (q_1)
              (q_1) edge  node {a,b} (q_2)
              (q_2) edge  node {a,b} (q_3)
              (q_3) edge [loop right] node {a,b} ();
          \end{tikzpicture}
        \item
          The hint given provides some intuition.
          We have to realize what happens when we see a new binary digit.
          Given the current value $p$:
            \begin{enumerate}
              \item If the next digit is $0$, then we have $2p$.
              \item If the next digit is $1$, then we have $2p+1$.
            \end{enumerate}
          We can catalog the effect in a table.

          \begin{tabular}{l | l | l}
            $p \equiv n \Mod{7}$ & $2p \equiv n \Mod{7}$ & $2p + 1 \equiv n \Mod{7}$ \\
            \hline
            0 & 0 & 1 \\
            1 & 2 & 3 \\
            2 & 4 & 5 \\
            3 & 6 & 0 \\
            4 & 1 & 2 \\
            5 & 3 & 4 \\
            6 & 5 & 6
          \end{tabular}

          We can then map these directly to states, where $0$ is the only accepting state.

          \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
             \node[state,initial,accepting] (q_0)   {$q_0$};
             \node[state] (q_1) [right=of q_0] {$q_1$};
             \node[state] (q_2) [right=of q_1] {$q_2$};
             \node[state] (q_3) [above right=of q_2] {$q_3$};
             \node[state] (q_4) [below right=of q_2] {$q_4$};
             \node[state] (q_5) [below right=of q_3] {$q_5$};
             \node[state] (q_6) [right=of q_5] {$q_6$};
              \path[->]
              (q_0) edge node {1} (q_1)
                    edge [loop above] node {0} ()
              (q_1) edge node {0} (q_2)
                    edge [bend left] node [pos=0.1] {1} (q_3)
              (q_2) edge node {0} (q_4)
                    edge node {1} (q_5)
              (q_3) edge [bend left] node [pos=0.15] {0} (q_6)
                    edge [bend right] node [above, pos=0.1] {1} (q_0)
              (q_4) edge [bend left] node [pos=0.1] {0} (q_1)
                    edge [bend left] node [below] {1} (q_2)
              (q_5) edge node [above, pos=0.2] {0} (q_3)
                    edge node {1} (q_4)
              (q_6) edge node {0} (q_5)
                    edge [loop right] node {1} ();
          \end{tikzpicture}
        \item
          We can extend the DFA presented above to ignore $\varepsilon$ and leading zeros.

          \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
             \node[state,accepting] (q_0)   {$q_0$};
             \node[state] (q_1) [right=of q_0] {$q_1$};
             \node[state] (q_2) [right=of q_1] {$q_2$};
             \node[state] (q_3) [above right=of q_2] {$q_3$};
             \node[state] (q_4) [below right=of q_2] {$q_4$};
             \node[state] (q_5) [below right=of q_3] {$q_5$};
             \node[state] (q_6) [right=of q_5] {$q_6$};
             \node[state] (fail) [below left=of q_4] {fail};
             \node[state,accepting] (0) [left=of fail] {$0$};
             \node[state,initial] (epsilon) [left=of 0] {$\varepsilon$};
              \path[->]
              (epsilon) edge node {0} (0)
                        edge node {1} (q_1)
              (0) edge node {0} (fail)
                  edge node {1} (q_1)
              (fail) edge [loop right] node {0,1} ()
              (q_0) edge node {1} (q_1)
                    edge [loop above] node {0} ()
              (q_1) edge node {0} (q_2)
                    edge [bend left] node [pos=0.1] {1} (q_3)
              (q_2) edge node {0} (q_4)
                    edge node {1} (q_5)
              (q_3) edge [bend left] node [pos=0.15] {0} (q_6)
                    edge [bend right] node [above, pos=0.1] {1} (q_0)
              (q_4) edge [bend left] node [pos=0.1] {0} (q_1)
                    edge [bend left] node [below] {1} (q_2)
              (q_5) edge node [above, pos=0.2] {0} (q_3)
                    edge node {1} (q_4)
              (q_6) edge node {0} (q_5)
                    edge [loop right] node {1} ();
          \end{tikzpicture}

        \item
          For this, it is easiest to begin enumerating possibilities.

          \[\{\varepsilon , 0, 1, 00, 11, 000, 010, 101, 111, 0000, \dots\}\]

          What we find is that the string must contain the same starting and ending character.

          \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
             \node[state,initial] (epsilon)   {$\varepsilon$};
             \node[state,accepting] (q_1) [above right=of epsilon] {$q_1$};
             \node[state] (q_2) [right=of q_1] {$q_2$};
             \node[state,accepting](q_3) [below right=of epsilon] {$q_3$};
             \node[state] (q_4) [right=of q_3] {$q_4$};
              \path[->]
              (epsilon) edge  node {0} (q_1)
                        edge  node {1} (q_3)
              (q_1) edge [loop above] node {0} ()
                    edge [bend right] node {1} (q_2)
              (q_2) edge [bend right] node [above] {0} (q_1)
                    edge [loop right] node {1} ()
              (q_3) edge [bend right] node {0} (q_4)
                    edge [loop below] node {1} ()
              (q_4) edge [bend right] node [above] {1} (q_3)
                    edge [loop right] node {0} ();
          \end{tikzpicture}
      \end{enumerate}

    \item[Problem 2]
      Since Regular languages are equivalent to DFA's, we work with DFA's.

      Given some DFA $M(L)$ we can construct a new DFA $M^R(L)$ that accepts $L^R$.

      Let $L = (Q, \Sigma, \delta, q_0, F)$.

      For each $q_i \in F$ we construct a new DFA $M_i = (Q, \Sigma, \delta_i, q_i, F_i)$
      where
      \begin{align*}
        \delta_i &::= \forall q_j, q_k \in Q, \forall x \in \Sigma, \delta(q_j, x) = q_k \implies \delta_i(q_k, x) = q_j \\
        F_i &::= {q_0}
      \end{align*}

      Each of these DFA's will accept a reversed string from $L$.
      So, if we take the union of all of these DFA's,
      we have a single DFA which accepts all reversed strings from $L$, for DFA's are closed under union.
  \end{enumerate}
\end{document}
